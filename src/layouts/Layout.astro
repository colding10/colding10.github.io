---
import '@/styles/global.css'
import '@/styles/gradients.css'
import '@/styles/typography.css'

import Footer from '@/components/Footer.astro'
import Head from '@/components/Head.astro'
import Header from '@/components/Header.astro'
import { SITE } from '@/consts'
import { cn } from '@/lib/utils'

interface Props {
	class?: string
}

const { class: className } = Astro.props
---

<!doctype html>
<html class="bg-background text-foreground custom-scrollbar" lang={SITE.locale}>
	<Head>
		<slot name="head" />
	</Head>
	<body class="prevent-shift">
		<div class="flex h-fit min-h-screen flex-col gap-y-6 font-sans">
			<div
				class="bg-background/95 border-border sticky-header sticky top-0 z-50 divide-y border-b backdrop-blur-md xl:divide-none"
				style="border-bottom: 1px solid #d6d3c9; border-bottom-color: var(--border, #d6d3c9);"
			>
				<Header />
				<slot name="subposts-navigation" />
				<slot name="table-of-contents" />
			</div>
			<main class="grow">
				<div
					class={cn(
						'mx-auto flex grow flex-col gap-y-6 px-4',
						className,
					)}
				>
					<slot />
				</div>
			</main>
			<Footer />
		</div>
	</body>
</html>

<script>
	// Handle scrollbar visibility to prevent double scrollbar effect
	document.addEventListener('DOMContentLoaded', () => {
		const html = document.documentElement
		let scrollTimeout: ReturnType<typeof setTimeout> | undefined

		// Add scrolling class when user scrolls
		function handleScroll() {
			html.classList.add('scrolling')
			clearTimeout(scrollTimeout)
			scrollTimeout = setTimeout(() => {
				html.classList.remove('scrolling')
			}, 1000) // Hide scrollbar after 1 second of no scrolling
		}

		// Listen for scroll events
		window.addEventListener('scroll', handleScroll, { passive: true })

		// Show scrollbar on hover over the right edge
		function handleMouseMove(e: MouseEvent) {
			const rightEdge = window.innerWidth - 20 // 20px from right edge
			if (e.clientX > rightEdge) {
				html.classList.add('scrolling')
			}
		}

		window.addEventListener('mousemove', handleMouseMove, { passive: true })

		// Ensure header border is always visible (extension-proof)
		function ensureHeaderBorder() {
			const headerContainer = document.querySelector('.sticky-header')
			if (headerContainer && headerContainer instanceof HTMLElement) {
				const computedStyle = window.getComputedStyle(headerContainer)
				const borderBottom = computedStyle.borderBottom

				// If border is not visible or has no width, force it
				if (
					!borderBottom ||
					borderBottom === '0px none rgb(0, 0, 0)' ||
					borderBottom.includes('0px')
				) {
					const isDark = html.getAttribute('data-theme') === 'dark'
					const borderColor = isDark ? '#3f3c49' : '#d6d3c9'
					headerContainer.style.setProperty(
						'border-bottom',
						`1px solid ${borderColor}`,
						'important',
					)
				}
			}
		}

		// Run immediately and after a short delay to catch extension interference
		ensureHeaderBorder()
		setTimeout(ensureHeaderBorder, 100)
		setTimeout(ensureHeaderBorder, 500)

		// Also run when theme changes
		const observer = new MutationObserver((mutations) => {
			mutations.forEach((mutation) => {
				if (
					mutation.type === 'attributes' &&
					mutation.attributeName === 'data-theme'
				) {
					setTimeout(ensureHeaderBorder, 50)
				}
			})
		})
		observer.observe(html, {
			attributes: true,
			attributeFilter: ['data-theme'],
		})
	})
</script>
